%% ----------------------------------------------- %%
%%            Graphical user interface             %%
%% (documentation chapter for the FilmTit project) %%
%% ----------------------------------------------- %%

The Graphical User Interface (GUI) is the part of the application that is loaded by the user in his web browser. It is written mostly in Java but compiled by the Google Web Toolkit (GWT) into JavaScript. Its main tasks are

\begin{itemize}
\item visualisation of the application and communication with the user in a user-friendly way, especially providing an efficient translation workspace adapted for translation of movie subtitles
\item communication with the User Space (see Chapter~\ref{chap:userspace}) through the Remote Procedure Calls (see Chapter~\ref{chap:communication}), especially to provide the user with translation suggestions from the core translation memory (see Chapter~\ref{chap:core}) and for data persistence
\end{itemize}

\section{Goals}
% (Honza)
Our main goal is to offer a tool for the translators of the movie subtitles as easy and effective to use as possible. With the capabilities of the current web browsers, we decided to make FilmTit a web-based application, therefore sparing the user the need to download and install anything.

\section{Google Web Toolkit}
% (Honza and Ruda)
The web-based user interface representing the client part of the FilmTit application is based on the Google Web Toolkit (GWT) framework. This technology is a development toolkit for building and optimizing browser-based applications %\citep{Gwtweb}
and is based on the idea of compilation of Java source code into JavaScript. Therefore, it enables us to write in Java even on the client side, but preserving most of the advantages of web application accessibility for the user.

The official description of GWT is as follows:

Google Web Toolkit (GWT) is a development toolkit for building and optimizing complex browser-based applications. Its goal is to enable productive development of high-performance web applications without the developer having to be an expert in browser quirks, XMLHttpRequest, and JavaScript. GWT is used by many products at Google, including Google Wave and the new version of AdWords. It's open source, completely free, and used by thousands of developers around the world.

More about decision for using GWT can be found in \ref{subsubsec:implementation:gwt}.

\subsection{Browser Support and Optimization}
GWT also provides a feature which makes the final web application similar in different major browsers and optimized to a certain degree for each of them. This feature is called {\em deferred binding} and it is based on generating different versions of the JavaScript code during compile time, only one of which needs to be loaded by a particular client browser at runtime. This process is by default maintained by the GWT compiler itself, so that the developer does not have to worry about it.

However, this ``unification'' is not complete, nor it is intended to be. It covers only the bigger and more crucial differences of the code behavior among various browsers, but does not address some slight variancies e.g.\ in design of the basic elements (and their most common behavior). This seems reasonable, because forcing each browser to interpret the code in the exact same way would mean hardcoding almost everything from scratch and not using many of their provided features, which would be probably impossible anyway. Nevertheless, some of these ``slight differences'' which we have encountered proved to be quite crucial for our intended design (especially in the event-handling domain), so lots of work had to be done to reasonably unify the application's behavior even among the major browsers.

Still, our hope is that GWT development will continue and will keep up with the development of web browsers, allowing us to provide browser-up-to-date versions of FilmTit simply by acquiring a new version of GWT and recompiling the project. Currently, the application works well with Opera v.~12
Firefox v.~14, Chrome v.~21 and Safari v.~5.1.5 or higher.


\subsection{Designing by UiBinder}
Another very useful and comfortable feature of the GWT for designing the user interface is the UiBinder. The idea behind this approach is to design the visual structure of the page (or its part) in an HTML-like way (this is called the {\em UiBinder template}) and its behavior and functionality in a Java class (called the {\em owner class} for the template). The UiBinder itself is then an object binding these two approaches together. This style of creating the web application supports the respected best practice to divide the visual design and the functionality. It also allows to create the web page's appearance in a way which is more natural to web designers (e.g. HTML-like), as well as more readable and modifiable. Other advantages include supposedly better performance (as the browsers can better optimize the rendering from the UiBinder templates than from the heavier-weight Java-based widgets and panels) and support for internationalization (not used by FilmTit at the moment).

The actual source code of a page designed this way (or of its segment) then consists of a file with the *.ui.xml Ui-Binder template (where also the style definition can be included directly) and a corresponding *.java owner class, where the elements of the template can be accessed as widgets (as well as made accessible to other classes). The owner class then can be simply instantiated and plugged into an existing design just like any other widget.

\subsection{Twitter Bootstrap Library}
For enhancing the visual appearance of our application to a modern look without a professional graphic designer, we have decided to use an existing open-source library for GWT which displays the page elements (and their groups) in the style of the Twitter pages. This library is called GWT-Bootstrap and is easily applicable with the UiBinder-style designing. It is also still a live project, so there is a hope that more features would be available in the possible future development.

Similarly to other third-party libraries used by FilmTit, the GWT-Bootstrap library is attached as a Maven dependency and downloaded automatically from its own Maven repository.


\section{GUI Structure}
% (Honza/Ruda)

The GUI is contained in the package {\tt cz.filmtit.client} (not {\tt cz.filmtit.gui} for ``historical'' reasons -- ``client'' is the default package name in GWT for the client side of a web application). All of it is written in Java (in its subset that is GWT-compilable to JavaScript), with occasional methods with bodies written directly in JavaScript (for reasons clarified in \ref{subsubsec:implementation:gwt}). Thus, the GUI can actually only be compiled to Javascript.

The GUI also makes use of the shared classes (package {\tt cz.filmtit.share}, see~\ref{sec:shared_classes}), which are written using only the intersection between standard Java and GWT-compilable Java and are therefore fully compilable both to Javascript and to Java bytecode.

Some settings have to be done via several resource files in the webapp directory. (This is required by the Java Servlets technology used to deploy the application.)

\subsection{Gui.java}

The main class is Gui.java. It defines the web application itself, providing an entry point, initialization methods, logging methods and access to page switching. It also contains fields that are considered global, such as the {\tt sessionID} of the currently logged in user.
It behaves as a static class, except for the {\tt onModuleLoad()} method required by GWT, which corresponds to the {\tt main()} function.

\subsection{Pages}

The subpackage {\tt cz.filmtit.client.pages} defines the pages of the application.
Please refer to the sitemap figure \ref{fig:sitemap} for an overview of the pages, which are:

\begin{itemize}
\item {\tt DocumentCreator}, used to create a new document
\item {\tt TranslationWorkspace}, the main page of the application where the actual translations take place
\item {\tt UserPage}, providing listing of user documents and the possibility to edit them
\item Settings, enabling the user to change several settings, such as his password or the maximum number of translation suggestions to show
\item {\tt WelcomeScreen}, displayed as the first page of the application
\item {\tt About}, showing basic information about the applicaton
\item {\tt PlayerInfo}, showing guidelines on how to run the media player
\item {\tt ChangePassword}, used as the target of the password change link sent by e-mail to users who forget their password, enabling them to set a new password
\item {\tt AuthenticationValidationWindow}, a special page that receives OpenID authentication data from an OpenID provider and passes them to User Space for validation
\item {\tt Blank}, a special page with no contents and is used to temporarily hide the contents of another page
\end{itemize}

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{figures/sitemap.pdf}
\end{center}
\caption{Site map of the application}
\label{fig:sitemap}
\end{figure}

As was already mentioned, each page has its layout and function separated as much as possible, with the function being defined in a <page>.java file and the layout in a UiBinder <page>.ui.xml file.

The pages package also contains the {\tt GuiStructure}, which defines the content panel, into which the individual pages are loaded, and the top menu, which enables the users to log in and out and to switch pages.

A page is created and loaded by calling its constructor, which may require some parameters (such as {\tt documentID} for {\tt TranslationWorkspace}).
Page loading and switching is handled by the {\tt PageHandler}, which also provides support for URLs: e.g.\ the About page can be accessed by a URL {\tt http://server/\#About} or {\tt http://server/?page=About} (the first one being the default), with the help of the GWT History class.

\subsection{Dialogs}

Apart from pages, the GUI also contains several dialogs that can be displayed on top of a page. The dialogs are defined in the {\tt cz.filmtit.client.dialogs} subpackage and are typically extended from the abstract {\tt Dialog} class in the same package.

The {\tt Dialog} class defines a modal dialog container and an ``interface'' to be used to handle the dialogs -- all dialogs should only be accessed via this interface (except for their creation, which is invoked by their constructor).
The interface methods are especially
{\tt deactivate()}, {\tt reactivate()}, {\tt showInfoMessage()}, {\tt showErrorMessage()} and {\tt close()}. To deactivate a dialog means to disable all of its active elements so that the user cannot interact with it and must wait for the dialog being reactivated or closed.

The Dialogs defined by the application are:
\begin{itemize}
\item {\tt LoginDialog}, used for logging in and related functions,
\item {\tt SessionIDPollingDialog}, used when waiting for OpenID login process to complete,
\item {\tt MediaSelector}, used to select the correct movie or series of a newly created document,
\item {\tt TimeEditDialog}, used to edit timing of subtitle items,
\item {\tt DownloadDialog}, which enables the user to download the translated subtitle file,
\item {\tt GoingOfflineDialog}, offering the user to turn on the Offline Mode, and
\item {\tt GoingOnlineDialog}, offering the user to upload data from Offline Mode when the user goes back online
\end{itemize}

\subsection{Remote Procedure Calls Implementation}

Each RPC is in GUI represented by a class from the {\tt cz.filmtit.client.callables} subpackage. The name of the class is typically similar to the RPC name -- e.g.\ for {\tt deleteDocument} RPC it is the {\tt DeleteDocument }class. Each of these classes is extended from the {\tt Callable superclass}, which will be described in the next section.

The RPC is invoked by creating a new instance of the callable class, providing the neccessary parameters in the constructor -- e.g. to invoke the {\tt simpleLogin()} RPC with the username and password parameters, one simply calls {\tt new SimpleLogin(username, password)}. A reference to the instance usually does not have to be kept, since the actions to take on success or failure of the RPC are already hard-coded into the onSuccessAfterLog and onFailureAfterLog methods of the class.

\subsubsection{Callable}

The institute of the {\tt Callable} superclass of all RPC classes has several purposes:

\begin{itemize}
\item to alleviate the burden of boiler-plate RPC invocation code by providing a wrapper for the ``raw'' RPC call
\item to provide utility methods and default actions, such as error handling
\item to provide actions to be always taken, such as logging of the calls with their parameters, and their results
\item to provide a common structure for all RPCs
\end{itemize}

The Callable class itself implements the {\tt AsyncCallback} interface, implementing the required {\tt onSuccess} and {\tt onFailure} methods; therefore, and instance of its subclass can be directly passed to the asynchronous call as the callback.

The subclasses representing the individual calls must only override the {\tt call()} method, which specifies the actual RPC to be invoked.
They can also modify the default behavior defined by the superclass by overriding several other methods, such as {\tt onSuccessAfterLog}, {\tt onEachReturn}, {\tt onFailureAfterLog}, {\tt onProbablyOffline} etc. This way, the behavior needed can be always achieved, but the default implementation is often sufficient, so the subclasses often override only one or two methods, keeping their code as simple as possible. (The method most often overridden is the {\tt onSuccessAfterLog} method; its default implementation is to do nothing, which is only good for RPCs that do not require any reaction of GUI on their successful return, such as {\tt changeDocumentTitle} or {\tt stopTranslationResults}.)

\subsubsection{Error Handling}

If the request fails for any reason, it is retried by default; four attempts are made for each request, always retrying after a short time interval.
Resending the request is the default behavior which the subclasses override in cases where it is obvious that resending will not help (e.g. incorrect e-mail address format or an already existing username on registration).

In case of network problems, both temporary and permanent (this cannot be easily distinguished), the GUI usually receives a {\tt StatusCodeException} with the status code 0. In such case the request is always resent three times before passing control to the {\tt onProbablyOffline} method (this behavior cannot be overridden).

There is also a timeout for each request after which the request is regarded as lost and is retried.

The default action in case of an error is to show the error message in a JavaScript alert window, except for the {\tt InvalidSessionIdException} where the default action is to ask the user to log in again.
The subclasses often override this by showing the message in a Dialog (invoking the {\tt reactivateWithErrorMessage} method of the {\tt Dialog} class), or by ignoring the error completely (e.g.\ when deleting a document, a failure with an {\tt InvalidDocumentIdException}, meaning that the document does not exist, is an error, but there is no need to inform the user because the result is the same as if the RPC succeeded: the document does not exist now.)

Most of the RPCs contain the {\tt sessionID} as one of their parameters to authenticate the user. All of such RPCs can thus throw an {\tt InvalidSessionIdException}, to which the default action is to show the Login Dialog to the user.

\subsection{Offline Mode}

The Offline Mode offers the users the possibility to continue translating a document even without a connection to the server. Their translations are stored locally in his browser and sent to User Space once they go back online.
Support for storing the data is ensured by the HTML5 Local Storage feature, which provides an in-browser data storage, accessible from JavaScript.
Each object is stored as a pair of a unique string key and a string value (therefore, serialization to string is necessary to store complex objects).

The Offline Mode support is separated into three parts: the {\tt LocalStorageHandler}, the {\tt Storable} interface, and classes implementing the interface (i.e. the {\tt SetUserTranslation} class).

\subsubsection{Storable interface}
\label{gui:subsubsec:storable}

This interface defines methods that need to be implemented by a class to be storable in the Local Storage, especially:

\begin{itemize}
\item {\tt toKeyValuePair()} -- to serialize the object into a pair of a key and a value

\item {\tt static fromKeyValuePair(KeyValuePair)} -- a factory method that deserializes the object from a pair of a key and a value (not actually defined by the interface; for a discussion on that matter see Section~\ref{ip:subsubsec:offline})

\item {\tt onLoadFromLocalStorage()} -- invoked by the {\tt LocalStorageHandler} when the user decides to upload the object
\end{itemize}

Each implementing class defines its serialization such that its key uniquely identifies the object and the value contains all data (except for those already contained in the key) needed to reconstruct the object.
(The key and the value are expected to consist of semicolon separated fields by default, but each class can define its own serialization, there are no restrictions other than defined by the String class.)

To store in the Local Storage, the key is extended to a ``full key'' by adding the {\tt classID} (e.g.\ ``SetUserTranslation'') and the {\tt userID} (a long),
so the resulting format of key is:

\begin{center}
full key = {\tt userID@classID:key}
\end{center}
When loading the object from the Local Storage, these added fields are used to indetify the owner of the object and the class to deserialize the object into, and are stripped before passing the key to the {\tt fromKeyValuePair()} method; thus, the class gets the key for deserialization in exactly the same format as it was produced by the class on serialization.

Unlike the key, the value is defined solely by the implementing class and is stored and loaded ``as is''.

The {\tt Storable} interface is currently only implemented by the {\tt SetUserTranslation} class, for reasons described in the Implementation Process chapter, section~\ref{par:process_serialization}.

\subsubsection{SetUserTranslation}

The {\tt SetUserTranslation} class defines its serialization key and value as follows:

\begin{itemize}
\item key = {\tt documentId;chunkId;partNumber}
\item value = {\tt chosenTranslationPair;userTranslation}
\end{itemize}

The onLoadFromLocalStorage() method implementation invokes the setUserTranslation RPC.

\subsubsection{LocalStorageHandler}

The static {\tt LocalStorageHandler} handles storing and loading of Storable objects to and from the Local Storage.

An important field is a boolean ``online'', which determines whether user is in Online Mode or Offline Mode. Setting this value is eqivalent to switching the Offline Mode on or off.

The {\tt LocalStorageHandler} implements especially the following (static) methods:

\begin{itemize}
\item {\tt storeInLocalStorage} (Storable) -- takes a Storable object, serializes it and stores it into the Local Storage

\item {\tt loadUserObjectsFromLocalStorage()} -- examines the Local Storage and returns a list of objects that belong to the current user

\item {\tt uploadUserObjects()} -- deserializes the loaded objects and invokes their onLoadFromLocalStorage() methods
\end{itemize}

\subsubsection{The Offline Mode operation}

Please see the sequence diagram \ref{gui:sd:offline_mode_1} for the first phase, where the user goes offline and continues working on the translation, and the sequence diagram \ref{gui:sd:offline_mode_2} for the second phase, where the user goes online again and the locally stored data are uploaded to the server.
(For simplicity the diagrams do not show some implementation details;
also, parameters are listed only if they are necessary for understanding the process.)

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.55]{figures/offline_mode_1.pdf}
\end{center}
\caption{Sequence diagram of turning on the Offline Mode and translating the document in Offline Mode.}\label{gui:sd:offline_mode_1}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.55]{figures/offline_mode_2.pdf}
\end{center}
\caption{Sequence diagram of the user going online after using Offline Mode.}\label{gui:sd:offline_mode_2}
\end{figure}

Before using the Local Storage, it is checked whether it is supported -- if it is not, Offline Mode is not offered to the user and a relevant message is displayed.

When a setUserTranslation call fails with the ``probably offline'' error, it is saved into a queue of failed calls that are to be stored offline if the user agrees (other {\tt setUserTranslation} calls could already have been invoked and will also fail and get enqueued). If the user decides to turn on the Offline Mode, all calls from the queue are stored into Local Storage.

In Offline Mode, the style of the menu is changed and all active components are hidden, because the user should not leave the Translation Workspace while in Offline Mode. Also, going back or forward using the browser controls is disabled: each upcoming page switch is cancelled.

The {\tt SetUserTranslation} calls invoked while in Offline Mode are not sent to server, but they are serialized into a key-value pair and stored in the Local Storage.

Once the user is back online and logs in again, the {\tt LocalStorageHandler} examines the Local Storage. It strips the {\tt userID} part of the key of each object found and compares it to the currently logged in user. If some data belonging to the users are found, they are informed about their count and are suggested to upload the data. If they agree, {\tt LocalStorageHandler} goes through the data, stripping off the ClassID and invoking the corresponding ``{\tt ClassID.fromKeyValuePair()}'' deserialization. Subsequently, the {\tt onLoadFromLocalStorage()} method is invoked on each of the resulting objects -- the {\tt SetUserTranslation} implementation of this method is to invoke the {\tt setUserTranslation call}, i.e.\ to store the translation on the server. When the call returns, {\tt LocalStorageHandler.SuccessOnLoadFromLocalStorage()} or {\tt LocalStorageHandler.FailureOnLoadFromLocalStorage()} is called, as required.

When each of the loaded objects has either succeeded or failed, the user is informed about the result. In case of errors, he can decide to retry loading the failed data or to delete them.

\subsection{SubgestBox}

An important class is the {\tt SubgestBox}, or ``SUBtitle sugGESTion BOX'', which visualizes the TM results, offering a variety of means of navigation through them.

\subsection{Playing the movie files}

From the beginning, we wanted to be able to show the user the movie file along with the translations. However, legal issues, bandwith issues and disk issues bar us from actually uploading the files to our servers -- so, we tried to implement some kind of playing the users' movie files, from their disks, in the browser, and then communicating with this player via JavaScript, so we can somehow connect it with the translation GUI.

For this, we have to deal with two problems.

\subsubsection*{Video Playback (VLCWidget)}
Playing the movie locally, from disk, is actually the lesser problem. We use VLC browser plugin for that.

VLC\footnote{\url{http://www.videolan.org/vlc/}, short for VideoLan Client} is a popular open source media player. One of its advantages is that it can handle almost any video format and any codec available.

VLC has also feature called ``browser plug-in''\footnote{For some reason, its name is different across VLC documentation. Sometimes, they use the name ``Mozilla plug-in'', sometimes ``Web plug-in'', sometimes ``browser plug-in''.}. The browser plug-in is not a part of standard VLC installation, but can be installed easily.

This browser plug-in can be used for playing local files, in the browser, given that the file address is known. It is possible to rewind forward/backward/stop, all through JavaScript.

There are some slight difficulties in the plug-in, though. One of them is, that it is not possible to jump on an exact time location in the video file. Most video files have so-called seek frames, which can appear more or less often (depending on the setting of the encoder), and VLC plugin always moves to the closest preceding seek frame. The difference can be quite big (even up to 20 seconds). This bars us for playing exactly the time slot of a given subtitle.

The other difficulty is that sometimes, the plugins just freezes without any warning after a move to a position. We have found out that it is somehow connected to the files played; with the exact same movie files, the exact same positions cause the player to crash, but slightly moved positions are all right.

The first issue is solved by not playing just the part with one subtitle, but bigger, 30 seconds ``windows''. The entire movie is split to these 30 second windows, and once the user switches in the {\tt TranslationWorkspace} from subtitle in one window to a subtitle in another window, the whole new window is played. It is actually better than playing just the time of the subtitle, since the user has more context to translate the movie's sentences.

The second issue is solved by detecting the crashes and restarting the whole plugin in the case of crash with slightly moved windows.

All is implemented in \texttt{cz.filmtit.client.widgets.VLCWidget}. Apart from that, the \texttt{VLCWidget} displays the subtitles on the left and on the right of the VLC browser plugin (original on the left, translated on the right).

We intentionally did not implement very sophisticated controls for the player (since it would make the design too complicated). All the player can do is replay the whole current window or pause the playing.

\subsubsection*{Java applet for reading the filename}
The bigger problem is actually \emph{reading the name of the file} before giving it to VLC player plugin.

The browsers are generally built to give pages as little access to user's system as possible (understandably so). That includes the file paths of the files. Even the recent HTML5 standards, that do have access to the file itself, cannot read the filename.

The only way we found, that would be usable across the browsers and systems, was to use a Java applet. Java applets have access to users' disk and can read the filenames; they have to be signed by a certificate, but that certificate can be self-signed.

This is implemented in \texttt{cz.filmtit.client.widgets.FileLoadWidget}.

The problem with this approach becomes evident -- we are now dependent on two external, non-standard, separate plug-ins for the task of playing video files -- VLC plugin and Java plugin. Both have to be installed separately, both often cause issues in various browsers (not only in theory). On the other hand, we achieved the almost impossible task -- playing movie files from users' disk on their browsers. When the is warn users that this functionality is experimental and carefully explain them the two plugins and their installation, we believe the current implementation is acceptable.


\subsection{Parsing and segmentation}
We already wrote about parsing in the chapter~\ref{parsing_subs}. As we mentioned there, we are reusing the same classes for {\tt dataimport} module (where we parsed and segmented thousands of files) in the GUI.

More information about the parsing can be found in the chapter~\ref{parsing_subs}.

\section{Typical Usage}
% (Honza)

\todo{update, some things changed...}

\subsection{Document Creation}

In the most typical case, users (already registered) will open the page with FilmTit and log in. Then, they will go to the {\tt DocumentCreator} page to create a new document. A document corresponds to one movie, or more precisely, to one subtitle file being translated from one language to another. On this page, the users should specify the title of the movie (or series), the direction of the translation (e.g.\ from English to Czech) and provide the actual local file with the source subtitles. They can also set a document title different from the movie title, and set a file path to the corresponding movie video file on his file system.
These information are sent to the User Space and, after refining the movie specification through the {\tt MediaSelector}, the new document is created and the page switches to {\tt TranslationWorkspace}, filled with source subtitles (segmented to chunks) together with their timing on the left side and corresponding empty translation text-boxes on the right side.

See also the corresponding sequence diagram \ref{gui:sd:document_creation}.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.40]{figures/document_creation_sequence_GUI.pdf}
\end{center}
\caption{Sequence diagram of document creation.}\label{gui:sd:document_creation}
\end{figure}

\subsection{Document Translation}
\label{sec:document_translation}

At the same time, the subtitle chunks are sent through the User Space to the Core, where the appropriate translation suggestions are generated for them and sent back. When received in the GUI, each translation result is set to the {\tt SubgestBox} corresponding to its chunk, and can be displayed on activation of the translation text-box as a pop-up, with the suggestions sorted according to their estimated accuracy.
The user can then choose any one of them (or none) and edit it (if necessary) to get the translation of the particular chunk. When the users leave the translation text-box, their translation is sent to the User Space through the {\tt setUserTranslation} call to be saved as the user translation of the chunk.

See also the corresponding sequence diagram \ref{gui:sd:document_translation}.
(Some technical details are ommitted for simplicity.)

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.45]{figures/document_translation_sequence.pdf}
\end{center}
\caption{Sequence diagram of document translation.}\label{gui:sd:document_translation}
\end{figure}