\label{chap:communication}
\label{sec:communication}

This chapter describes the communication interface between the GUI and the Userspace. The central part of the interface are Remote Procedure Calls, described in XXX, YYY and ZZZ, but some of the sequences span more than one RPC: these are further described in XXX.

\section{Remote Procedure Calls}

GUI communicates with Userspace via a GWT RemoteService implementation, defined as the FilmTitService interface.
The interface provides asynchronous RPC methods (the responses are processed by callbacks).

The method is always called from the client, because Javascript security policies do not allow to handle incoming calls.
Therefore, in case the Userspace needs to actively contact the GUI without the GUI having sent a request before,
this has to be implemented in the GUI by polling.

The method always returns an instance of the return type on success or an instance of an exception on failure.
In case of common points of failure that do not qualify as an exceptional state, such as user registration attempt with an already existing username, the common failure is typically signalled by the return value instead (typically a null or a false).

Most of the RPCs can only be invoked by a logged in user. Such RPCs always have the sessionID as their first parameter to authenticate the user and can throw an InvalidSessionIdException.

\section{Manipulating Documents}

TODO: See shared Document, see shared Chunk, see shared TimedChunk.
(Needed to understand e.g. movieTitle or ChunkIndex.)

A document is always identified by its documentID (a long number generated by Userspace on document creation), therefore most of the methods have the documentID as one of their parameters.

A chunk in the document can always be identified by its ChunkIndex, but for convenience in some cases the whole chunk is sent instead.
\todo{we should most probably send only the ChunkIndex always (except for saveSourceChunks of course)}

\subsection{Whole Document Operations}

\subsubsection{DocumentResponse createNewDocument(String sessionID, String documentTitle, String movieTitle, String language, String moviePath)}

Creates the document
(without source chunks, which have to be added by calling saveSourceChunks),
returns its id, together with media source suggestions based on movieTitle.
     	
\subsubsection{Void selectSource(String sessionID, long documentID, MediaSource selectedMediaSource)}
Sets the media source of the document. The media source represents the movie or series which the subtitles come from.

\subsubsection{List<Document> getListOfDocuments(String sessionID)}
Returns all documents owned by the user, ordered by date and time of last change.

\subsubsection{Document loadDocument(String sessionID, long documentID)}
Returns the document with the given id, with source chunks but without translation suggestions (these have to be explicitely requested by getTranslationResults).

\subsubsection{Void changeDocumentTitle(String sessionID, long documentID, String newTitle)}
Sets a different title for the document.

\subsubsection{List<MediaSource> changeMovieTitle(String sessionID, long documentID, String newMovieTitle)}
Returns media source suggestions based on newMovieTitle.
The movie title is not changed yet,
this is only done on calling selectSource.
TODO: is this true?     	 
     	
\subsubsection{Void deleteDocument(String sessionID, long documentID)}
Remove the given document from the list of user's documents.
(The data might not be discarded immediately
as the translations still might be used to enrich the translation memory)	 

\subsection{Source Subtitles Operations}

\subsubsection{Void saveSourceChunks(String sessionID, List<TimedChunk> chunks)}
Save the given source chunks as the contents of the given document
(which was already created by calling createNewDocument).

\subsubsection{Void setChunkStartTime(String sessionID, ChunkIndex chunkIndex, long documentID, String newStartTime)}
Change the start time of the given chunk to the new value. The value must be in the SRT format, i.e. hh:mm:ss,ttt.

\subsubsection{Void setChunkEndTime(String sessionID, ChunkIndex chunkIndex, long documentID, String newEndTime)}
Change the end time of the given chunk to the new value. The value must be in the SRT format, i.e. hh:mm:ss,ttt.

\subsubsection{Void setChunkTimes(String sessionID, ChunkIndex chunkIndex, long documentID, String newStartTime, String newEndTime)}
Change the start time and end time of the given chunk to the values. The values must be in the SRT format, i.e. hh:mm:ss,ttt.

\subsubsection{TranslationResult changeText(String sessionID, TimedChunk chunk, String newDbForm)}
Change the source text of the chunk,
resulting in new translation suggestions
which are sent as the result.

\todo{why dont we send the ChunkIndex and documentID instead?}

\subsubsection{Void deleteChunk(String sessionID, ChunkIndex chunkIndex, long documentID)}
Remove the chunk from the document, together with its translation if it exists.

\subsection{Target Subtitles Operations}

\subsubsection{TranslationResult getTranslationResults(String sessionID, TimedChunk chunk)}
Get the list of possible translations of the given chunk.
The TranslationResult instance contains zero or more translation suggestions, which come from the Translation Memory and/or the Machine Translation System.

\subsubsection{List<TranslationResult> getTranslationResults(String sessionID, List<TimedChunk> chunks)}
Get the list of lists of possible translations of the given chunks.
Each TranslationResult instance contains zero or more translation suggestions, which come from the Translation Memory and/or the Machine Translation System.

\subsubsection{Void stopTranslationResults(String sessionID, List<TimedChunk> chunks)}
Stop generating translation results for the given chunks
(to be called after getTranslationResults has been called
with the given chunks).

\subsubsection{Void setUserTranslation(String sessionID, ChunkIndex chunkIndex, long documentID, String userTranslation, long chosenTranslationPairID)}
Save the user translation of the given chunk (no matter whether it is user\'s own translation or a suggestion taken over or post-edited).
The id of the TranslationPair chosen for post-editing is also sent, providing feedback which then can be used to improve future suggestions.

\section{User Registration and Login}

The user is required to log in to use the application.

The user is logged in if he has a valid sessionID which is linked to a user account.
The sessionID expires after a given period of time without any user interaction with the server,

Two ways to log in are supported -- Simple Login and OpenID Login; these are further decribed separately. The only two common methods are checkSessionID and logout.

\subsubsection{SessionResponse checkSessionID(String sessionID);}
Validates the given sessionID. To be used with a sessionID that does not result from invoking neither simpleLogin nor getSessionID (such as a sessionID stored in a cookie).
Returns a SessionResponse instance containing the sessionID and the User object if the sessionID is valid, or null otherwise.

\subsubsection{Void logout(String sessionID)}
Invalidate the user session with the given sessionID.

\subsection{Simple Login and Registration}
\label{subsec:simple_login}

The Simple Login is the classical implementation of user login. Each user must first register with a unique username and a password of choice. These credentials are then used to log into the application. (The password is to be stored on the server side in the form of a one-way hash.)

The user can also provide an e-mail address for forgotten password retrieval. He then has the option to request a password reset e-mail, based on his username or e-mail address. The password reset e-mail contains a link to a page where the user can set a new password, based on a temporary password change token.

\subsubsection{Boolean registration(String username, String password, String email)}
Register a user with the given username and password, also setting the e-mail address if provided and sending registration info to it.
Returns true on success, false if the username is already taken, and an exception in case of other errors (usually an invalid e-mail address).

\subsubsection{SessionResponse simpleLogin(String username, String password)}
Try to log in the user with the given username and password.
Returns a SessionResponse instance containing the sessionID and the User object on success, or null if the credentials are invalid.

\subsubsection{Boolean sendChangePasswordMail(String username)}
Send a password reset e-mail
to the e-mail address of the user with the given username.
Returns true if the e-mail is successfully sent;
returns false if the username is not registered or there is no e-mail address stored with the corresponding user account.

\subsubsection{Boolean sendChangePasswordMailByMail(String email)}
Send a password reset e-mail to the given e-mail address.
The password reset link is bound to a username;
therefore, if there are multiple user accounts with the given e-mail address,
multiple password reset e-mail are sent to the e-mail address.
Returns true if the e-mail is successfully sent;
returns false if the e-mail address is not registered with any user account.

\subsubsection{Boolean changePassword(String username, String password, String token)}
Set a new password in case of forgotten password.
The temporary password change token must be still valid,
and identical to one sent in the password reset e-mail
to the user with the given username.
Returns true if the password change is successful;
returns false if the token is not valid.

\subsection{Login via OpenID Services}
\label{subsubsec:gui_openid}

The OpenID Login process is described in detail in a separate section \ref{sec:OpenID_Login}.

\subsubsection{LoginSessionResponse getAuthenticationURL(AuthenticationServiceType serviceType)}

Return the URL of a window to show to the user to log in using his OpenID account at an OpenID provider specified by serviceType. It leads to a webpage of the OpenID provider, with the return page set to the FilmTit application, to the AuthenticationValidationWindow page.

A generated temporary one-time identifier, authID, is also included in the response. It is used to pair the authentication process, which takes place in the newly opened window, with the main GUI window.

\subsubsection{Boolean validateAuthentication(int authID, String responseURL);}

Validate the response URL from the OpenID provider, which contains information about the result of the OpenID authentication.

If the authentication is found to have been successful, a new session is generated for the user and paired with the given authID, and true is returned.
Otherwise, the method returns false.

\subsubsection{SessionResponse getSessionID(int authID)}

Check whether the user has already successfully logged in using his OpenID with the given authID.

\begin{itemize}
\item If yes, the corresponding sessionID and User object are returned.
\item If not yet, but the authID is valid, which means that an OpenID login operation is probably still in progress, null is returned.
\item Otherwise, an exception is thrown.
\end{itemize}

\section{User Settings}

There are several settings that the user can change. There is a separate call for each of the settings -- therefore, a set of indivdual calls must be invoked if the user decides to change multiple settings at once, and each of the calls can succeed or fail independently on the results of the other calls.

The settings are stored in the User object and sent to GUI on login, as a part of the SessionResponse which is the result of the methods simpleLogin, getSessionID and checkSessionID. There is no dedicated method to load the settings; checkSessionID is to be used for that purpose.

\subsection{Account and Logging in Settings}

\subsubsection{Void setUsername(String sessionID, String username)}
Change user's username.

\subsubsection{Void setPassword(String sessionID, String password)}
Change user's password.

\subsubsection{Void setEmail(String sessionID, String email)}
Change user's e-mail.

\subsubsection{Void setPermanentlyLoggedIn(String sessionID, boolean permanentlyLoggedIn)}
Stay logged in permanently (for 1 month) instead of 1 hour (sets the session timeout)

\subsection{Translation Workspace Settings}

\subsubsection{Void setMaximumNumberOfSuggestions(String sessionID, int number)}
Set maximum number of suggestions to show for each line.

\subsubsection{Void setUseMoses(String sessionID, boolean useMoses)}
Include Machine Translation results in translation suggestions.

\section{Remote Logging}

The remote logging is used to log messages from GUI on server. The messages are to be printed in the server log and can also be stored in the database.

\subsubsection{Void logGuiMessage(LevelLogEnum level, String context, String message, String sessionID)}
Log the given message from GUI on server.
The suported levels are DebugNotice, Notice, Warning and Error.
The context specifies the type of the message and should be constant for each instance of a similar message; it can contain e.g. a class name, a method name or an RPC name. The message should be as detailed as to provide all necessary information, including e.g. values of variables or a stacktrace if applicable.

The sessionID is only used to include the userID in the logged message; it is to be null if the user is not logged in.

\section{Exceptions Thrown by RPCs}

The RPCs typically throw an exception on failure. These exceptions should be of only four types, described in this section.

\subsection{InvalidSessionIdException}

Most of the RPCs can only be invoked by a logged in user -- such RPCs take the sessionID as their first parameter and throw an InvalidSessionIdException in case of an invalid sessionID. Typically the ID would be originally valid but expired, so the expected reaction to this exception is to simply ask the user to log in again.

\subsection{InvalidDocumentIdException}

RPCs that manipulate the document usually take the documentID as a parameter and throw an InvalidDocumentIdException if a document with the given ID does not exist or does not belong to the user.

\subsection{InvalidChunkIdException}

RPCs that manipulate individual chunks take either the whole chunks or only their indexes as a parameter. They throw an InvalidChunkIdException if the specified chunk does not exist.

\subsection{InvalidValueException}

The InvalidValueException is thrown by a method if a value provided by the user, such as an e-mail address or a password, does not have the required format. It always contains details about the nature of the error as the message, which usually should be shown to the user.

\section{Complex Operations}

In most cases, one RPC is sufficient to perform the whole operation. However, sometimes a whole sequence of several RPCs is required to complete one complex operation. Such operations are described in this section.

\subsection{Document Creation}

see \ref{rpc:sd:document_creation}

\todo{describe textually}

\todo{probably translation suggestions generation does not belong here}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.65]{figures/document_creation_sequence_RPC.pdf}
\end{center}
\caption{Sequence diagram of document creation, including translation suggestions loading.}\label{rpc:sd:document_creation}
\end{figure}

\subsection{OpenID Login}
\label{sec:OpenID_Login}

This section describes the OpenID Login process, which is also shown in the sequence diagram \ref{rpc:sd:openid_login}.

The authentication itself is done in a new authentication window.
A successful authentication in the authentication window is then paired with the GUI main window using a temporary one-time identifier, authID, shared by the Userspace, the main GUI window and the authentication window.
(Because of Javascript security restrictions, there is no simple way of sending the result of the authentication process from the authentication window to the main window;
however, the authID can be sent to the new window easily because it is already known at the time of its creation.)

When OpenID Login is requested by the user, the GUI main window calls getAuthenticationURL.
The Userspace generates an authID, and a URL to be used for the authentication, and returns that to the GUI, which opens a new authentication window with the received URL.
The URL points to an OpenID provider webpage (currently supported OpenID providers are Google, Yahoo and Seznam). As a GET parameter, it contains the return URL, which leads back to FilmTit -- to the AuthenticationValidationWindow page, including the authID as a GET parameter in the return URL.

After opening the authentication window, GUI starts waiting for the user to authenticate. The waiting is active, polling the Userspace with getSessionID in regular intervals until a non-null value is returned.

Meanwhile, the user can authenticate in the authentication window. The OpenID provider then redirects the user to the return URL, which is the AuthenticationValidationWindow, together with parameters describing the result of the authentication and providing some information about the user (see \todo{link to userspace} for details).
The whole response URL is then sent through validateAuthentication to Userspace for validation.

If Userspace finds the authentication to be successful, a new session is created for the user, and the sessionID is stored in a pair with the authID.
If a user with the given OpenID is not registered yet, registration is transparently performed at this moment (see \todo{link to userspace} for details); no explicit registration is required for OpenID login.
The authentication window is then closed.
In case of an error, the error message is displayed in the authentication window (and the window stays open).

When a successful authentication took place, the getSessionID method returns the sessionID and a User object, the polling stops and the authentication process is completed.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.55, angle=90]{figures/openid_login_sequence.pdf}
\end{center}
\caption{Sequence diagram of OpenID login.}\label{rpc:sd:openid_login}
\end{figure}
