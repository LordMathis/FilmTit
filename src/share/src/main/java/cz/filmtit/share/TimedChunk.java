package cz.filmtit.share;

import java.io.Serializable;


public class TimedChunk extends Chunk implements com.google.gwt.user.client.rpc.IsSerializable, Serializable,
Comparable<TimedChunk> {
	// TODO: should be long - probably number of milliseconds 
	private String startTime;
    private String endTime;
    private int partNumber;

    public ChunkIndex chunkIndex;

    //TODO: do we need this in the end?
    //DO: no, we don't private int index=0;
    
    // Generated by GUI
    private int id = Integer.MIN_VALUE;
    
    // Document.id
    private long documentId = Long.MIN_VALUE;

    public TimedChunk() {
    	// nothing;    	
    }

    public ChunkIndex getChunkIndex() {
        return chunkIndex;
    }
    
    public static long timeToLong(String time) {
        String[] times = time.split("[,:.]");
        Long hour = Long.valueOf(times[0].replaceAll(" ",""));
        Long minute = Long.valueOf(times[1].replaceAll(" ",""));
        Long second = Long.valueOf(times[2].replaceAll(" ",""));
        Long mili = Long.valueOf(times[3].replaceAll(" ", ""));
        return hour*3600*1000+minute*60*1000+second*1000+mili;
    }
/*    public int getIndex() {
        return index;
    }

    public void setIndex(int index) {
        this.index=index;
    }*/
    
    public TimedChunk(String startTime, String endTime, int partNumber, String text, int id, long documentId) {
        super(text);
        this.startTime = startTime;
        this.endTime = endTime;
        this.partNumber = partNumber;
		this.id = id;
		this.documentId = documentId;
        this.chunkIndex = new ChunkIndex(partNumber, id);
    }

    public long getStartTimeLongNonZero() {
        long r = timeToLong(getStartTime());
        if (r<=0) {
            return 1;
        }
        return r;
    }

    public String getStartTime() {
        return startTime;
    }

    public void setStartTime(String startTime) {
        this.startTime = startTime;
    }

    public String getEndTime() {
        return endTime;
    }

    public void setEndTime(String endTime) {
        this.endTime = endTime;
    }

    public int getPartNumber() {
        return partNumber;
    }

    public void setPartNumber(int partNumber) {
        this.partNumber = partNumber;
        this.chunkIndex = new ChunkIndex(partNumber, id);
    }

	public int getId() {
		return id;
	}

    public void setId(int id) {
        if (this.id == id) { return; }
        if (this.id != Integer.MIN_VALUE) {
            throw new UnsupportedOperationException("Once the timed chunk ID is set, it cannot be changed.");
        }
        this.chunkIndex = new ChunkIndex(partNumber, id);
        this.id = id;
    }

	public long getDocumentId() {
		return documentId;
	}

    public void setDocumentId(long documentId) {
        if (this.documentId == documentId) { return; }
        if (this.documentId != Long.MIN_VALUE) {
            throw new UnsupportedOperationException("Once the parent document ID is set, it cannot be changed.");
        }
        this.documentId = documentId;
    }

    
    /**
     * Comparing according to their order in the file/movie
     * - by startTime, endTime and partNumber, respectively.
     * (returns 0 iff all these three are the same)
     */
	@Override
	public int compareTo(TimedChunk that) {
		// TODO: compare differently for various subtitle formats, i.e.
		// - lexicographically for srt
		// - numerically for sub
		// - ???
		
		// ? this.startTime < that.startTime ?
		int result = this.startTime.compareTo(that.startTime);
		
		if (result == 0) {	// this.startTime == that.startTime
			// ? this.endTime < that.endTime ?
			result = this.endTime.compareTo(that.endTime);			
			
			if (result == 0) {	// this.endTime == that.endTime
				// ? this.partNumber < that.partNumber ?
				result = this.partNumber - that.partNumber;
			}
		}
		return result;
	}
	
	/**
	 * When comparing two TimedChunks, equal iff their proper compareTo returns 0.
	 */
	@Override
	public boolean equals(Object that) {
		if (that instanceof TimedChunk) {
			return (this.compareTo((TimedChunk)that) == 0) ? true : false;
		}
		else return super.equals(that);
	}
}
